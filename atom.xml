<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luthree&#39;s Blog</title>
  
  <subtitle> </subtitle>
  <link href="https://blog.luthr.ee/atom.xml" rel="self"/>
  
  <link href="https://blog.luthr.ee/"/>
  <updated>2025-05-24T09:08:44.484Z</updated>
  <id>https://blog.luthr.ee/</id>
  
  <author>
    <name>luthree</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Python的图形化点名系统</title>
    <link href="https://blog.luthr.ee/posts/A-name-picker-based-on-Python/"/>
    <id>https://blog.luthr.ee/posts/A-name-picker-based-on-Python/</id>
    <published>2025-05-24T07:39:36.000Z</published>
    <updated>2025-05-24T09:08:44.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、要实现的功能"><a href="#一、要实现的功能" class="headerlink" title="一、要实现的功能"></a>一、要实现的功能</h1><ul><li>随机点名</li><li>在一定数量范围内不会重复点到同一个人</li><li>便于操作的图形化界面</li><li><span class="blur">修改指定名字被点到的概率</span></li></ul><h1 id="二、功能的实现"><a href="#二、功能的实现" class="headerlink" title="二、功能的实现"></a>二、功能的实现</h1><h2 id="1-库的导入"><a href="#1-库的导入" class="headerlink" title="1. 库的导入"></a>1. 库的导入</h2><p>使用<code>tkinter</code>和<code>random</code>库可以帮助我们实现图形化界面和随机点名：</p><pre><code>    import tkinter as tk    import random</code></pre><h2 id="2-搭建图形界面"><a href="#2-搭建图形界面" class="headerlink" title="2. 搭建图形界面"></a>2. 搭建图形界面</h2><p>用以下的代码可以搭建一个简单的点名页面：</p><pre><code>    def __init__(self, master):        self.master = master                master.title(&quot;点名器&quot;)        self.label = tk.Label(master, text=&quot;     点名结果:      &quot;, font=(&quot;宋体&quot;, 30))        self.label.pack(pady=20)        self.result = tk.Label(master, text=&quot;&quot;, font=(&quot;宋体&quot;, 34), fg=&quot;red&quot;)        self.result.pack(pady=20)        self.pick_button = tk.Button(master, text=&quot;开始点名&quot;, command=self.toggle_picking, font=(&quot;宋体&quot;, 28))        self.pick_button.pack(pady=20)</code></pre><p>其中：</p><ul><li><code>self.result</code>为显示点名结果的标签。</li><li><code>self.pick_button</code>为开始&#x2F;结束按钮。</li></ul><h2 id="3-获取名单"><a href="#3-获取名单" class="headerlink" title="3. 获取名单"></a>3. 获取名单</h2><p>为实现随机点名，我们必须要做的是获取所有人的姓名，其可以用以下代码实现：</p><pre><code>    with open(&quot;names.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as tf:            self.names = tf.read().split(&quot;\n&quot;)</code></pre><p>其中：</p><ul><li>文件<code>names.txt</code>是储存名单的文件。</li><li>列表<code>self.names</code>用于在程序中储存名单。</li><li>函数<code>tf.read().split(&quot;\n&quot;)</code>用于按照换行分割名字</li></ul><p>引号中的文件名在没有路径修饰的情况下会默认读取与程序同目录下的文件。我们也可以将其改成绝对路径：</p><pre><code>    with open(&quot;C://names.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as tf:</code></pre><h2 id="4-随机点名"><a href="#4-随机点名" class="headerlink" title="4. 随机点名"></a>4. 随机点名</h2><p>要实现随机点名，我们需要调用<code>random</code>下的<code>choice</code>来在列表中选择：</p><pre><code>    def choose_name(self):        final_name = random.choice(names)        return final_name</code></pre><h2 id="5-排除点过的名字"><a href="#5-排除点过的名字" class="headerlink" title="5. 排除点过的名字"></a>5. 排除点过的名字</h2><p>我们不会希望一个人因为运气好而被连续点到，因此需要在点到一个人后将他的名字排除在外。</p><p>我们先定义一个列表用于储存已经点过的名字：</p><pre><code>    self.named = []</code></pre><p>然后将列表中的名字排除：</p><pre><code>    def choose_name(self):        # 过滤出有效的名字列表，排除已经点过的名字        available_names = [name for name in self.names if name not in self.named]        # 如果没有可选名字，则直接返回 &quot;无可选名字&quot;        if not available_names:            return &quot;无可选名字，请重启应用后重试&quot;</code></pre><h2 id="6-将点名结果显示在屏幕上"><a href="#6-将点名结果显示在屏幕上" class="headerlink" title="6. 将点名结果显示在屏幕上"></a>6. 将点名结果显示在屏幕上</h2><p>将点名结果<code>final_name</code>显示在结果标签中，然后将其记录在<code>self.named</code>中：</p><pre><code>    def pick_final_name(self):        self.count += 1  # 点名次数增加        final_name = self.choose_name()        # 显示最终点名结果        self.result.config(text=final_name)        # 如果记录的名字超过20次，移除最早的名字        if self.count &gt;= 20:            self.named.pop(0)        self.named.append(final_name)</code></pre><h2 id="7-点名时实现滚动动画"><a href="#7-点名时实现滚动动画" class="headerlink" title="7. 点名时实现滚动动画"></a>7. 点名时实现滚动动画</h2><p>为营造点名的紧张感，我们可以用以下代码来实现名字在屏幕上滚动的效果：</p><pre><code>    def roll_names(self):        if self.is_picking:            name = random.choice(self.names)            self.result.config(text=name)            self.master.after(25, self.roll_names)</code></pre><p>其中：<code>self.is_picking</code>记录了点名器的状态，其可以用先前定义的按钮来控制：</p><pre><code>    def toggle_picking(self):        self.is_picking = False        if not self.is_picking:            self.is_picking = True            self.pick_button.config(text=&quot;停止点名&quot;)            self.roll_names()        else:            self.is_picking = False            self.pick_button.config(text=&quot;开始点名&quot;)            self.pick_final_name()</code></pre><h2 id="8-实现隐藏功能"><a href="#8-实现隐藏功能" class="headerlink" title="8. 实现隐藏功能"></a>8. 实现隐藏功能</h2><div class="collapse-box-control">    <div class="collapse-box-header"><div class="collapse-box-icon"><i class="fa fa-plus"></i></div><span>隐藏的内容</span></div>    <div class="collapse-box-content"><div class="inner">        <p>在此基础上我们可以实现修改指定名字被点到的概率。首先定义一个列表用于储存特殊的名字：</p><pre><code>    self.skip_names = [&quot;张三&quot;]</code></pre><p>然后修改他被点到的概率：</p><pre><code>    if self.skip_names in available_names and random.random() &lt; 0.5:        available_names.remove(self.skip_names)</code></pre><p>其中：<code>random.random() &lt; 0.5</code>代表其被点到后有50%的概率被跳过。</p>     </div></div>    </div><h1 id="三、成品"><a href="#三、成品" class="headerlink" title="三、成品"></a>三、成品</h1><pre><code>    import tkinter as tk    import random    class NamePicker:        def __init__(self, master):            self.master = master            self.count = 0  # 初始化计数器                        master.title(&quot;点名器&quot;)            self.label = tk.Label(master, text=&quot;     点名结果:      &quot;, font=(&quot;宋体&quot;, 30))            self.label.pack(pady=20)            self.result = tk.Label(master, text=&quot;&quot;, font=(&quot;宋体&quot;, 34), fg=&quot;red&quot;)            self.result.pack(pady=20)            self.pick_button = tk.Button(master, text=&quot;开始点名&quot;, command=self.toggle_picking, font=(&quot;宋体&quot;, 28))            self.pick_button.pack(pady=20)            # 读取名字列表            with open(&quot;names.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as tf:                self.names = tf.read().split(&quot;\n&quot;)                            # 跳过的名字列表            self.skip_names = [&quot;张三&quot;]            # 记录已经点过名的名单            self.named = []            self.is_picking = False        def toggle_picking(self):            if not self.is_picking:                self.is_picking = True                self.pick_button.config(text=&quot;停止点名&quot;)                self.roll_names()            else:                self.is_picking = False                self.pick_button.config(text=&quot;开始点名&quot;)                self.pick_final_name()        def roll_names(self):            if self.is_picking:                name = random.choice(self.names)                self.result.config(text=name)                self.master.after(25, self.roll_names)        def pick_final_name(self):            self.count += 1  # 点名次数增加            final_name = self.choose_name()            # 显示最终点名结果            self.result.config(text=final_name)            # 如果记录的名字超过20次，移除最早的名字            if self.count &gt;= 20:                self.named.pop(0)            self.named.append(final_name)        def choose_name(self):            # 限制最大重试次数，防止死循环            max_attempts = 100              attempts = 0            while attempts &lt; max_attempts:                attempts += 1                # 过滤出有效的名字列表，排除跳过名单和已经点过的名字                available_names = [name for name in self.names if name not in self.named]                # 如果点名次数 &lt;= 10，跳过 `skip_names` 中的所有名字                if self.count &lt;= 10:                    available_names = [name for name in available_names if name not in self.skip_names]                # 如果点名次数 &gt; 10，只对第一个名字 50% 概率跳过                elif self.count &gt; 10 and self.skip_names[0] in available_names and random.random() &lt; 0.5:                    available_names.remove(self.skip_names[0])                # 如果没有可选名字，则直接返回 &quot;无可选名字&quot;                if not available_names:                    return &quot;无可选名字，请重启应用后重试&quot;                final_name = random.choice(available_names)                # 如果选中的名字不在最近20次内，则返回这个名字                if final_name not in self.named:                    return final_name            # 如果达到最大尝试次数，返回最后选中的名字以避免死循环            return final_name    if __name__ == &quot;__main__&quot;:        root = tk.Tk()        app = NamePicker(root)        root.mainloop()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、要实现的功能&quot;&gt;&lt;a href=&quot;#一、要实现的功能&quot; class=&quot;headerlink&quot; title=&quot;一、要实现的功能&quot;&gt;&lt;/a&gt;一、要实现的功能&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;随机点名&lt;/li&gt;
&lt;li&gt;在一定数量范围内不会重复点到同一个人&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="软件开发" scheme="https://blog.luthr.ee/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Python" scheme="https://blog.luthr.ee/tags/Python/"/>
    
    <category term="工具" scheme="https://blog.luthr.ee/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>你好，世界！</title>
    <link href="https://blog.luthr.ee/posts/hello-world/"/>
    <id>https://blog.luthr.ee/posts/hello-world/</id>
    <published>2025-05-23T16:00:00.000Z</published>
    <updated>2025-05-24T08:01:49.812Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到luthree’s Blog</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;欢迎来到luthree’s Blog&lt;/p&gt;
</summary>
      
    
    
    
    <category term="开始" scheme="https://blog.luthr.ee/categories/%E5%BC%80%E5%A7%8B/"/>
    
    
    <category term="欢迎" scheme="https://blog.luthr.ee/tags/%E6%AC%A2%E8%BF%8E/"/>
    
  </entry>
  
</feed>
