[{"title":"C语言中如何随输入字符动态扩展数组大小","date":"2025-11-24T14:07:45.000Z","url":"/posts/how-to-dynamically-expand-array-size-based-on-input-characters-in-c/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["C","/tags/C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"前言C语言中，数组须在声明时指定大小，这使得我们在使用静态数组时必须在获取输入前就得知输入的内容大小。本篇文章将要介绍我是如何通过动态内存分配实现无感（无需用户和开发者手动干预）扩展数组大小的。 基本概念 malloc() 函数可以为指针分配内存； realloc() 函数可以为指针重新分配内存； free() 函数用于释放内存； getchar() 函数执行一次会读取一个字符。 实现方法初始化内存大小通过指令 便可为指针 input 分配 size * sizeof(char) 大小的内存。其中， sizeof(char) 用于获取单个 char 类型变量所需的内存大小。 扩展数组为实现能在接收输入的同时无感的扩展数组大小，我们需要设计一个循环，让其能够在读取到每一个字符时判断是否需要扩展数组大小： 通过这样一个 while 循环，我们便可以在计数器 i 达到数组边界时自动将数组扩展一定量的大小。 通过利用临时变量 ch ，我们可以在判断是否超出预设内存大小后再将输入值写入 input 中，以防向超过内存大小的区域中写入值。 错误处理在使用动态内存分配时，我们需要注意检查内存是否分配成功。这时就需要引入以下代码： 这样就可以在内存分配失败时得到提醒并返回错误。 注意：在数组使用结束后需及时释放内存： free(input) 示例以上便是针对动态扩展数组大小这个问题我给出的解决方案。下面是一个使用了以上解决方案的示例。 题目：编写一个程序，定义两个字符数组，对第一个数组通过用户输入录入一串字符直到遇到 \\n 结束，将第一个数组的小写字符转换为大写字符，大写字符转换为小写字符，其他字符保持不变，将结果保存在第二个数组中。将第二个数组输出。 示例程序 "},{"title":"基于Python的图形化点名系统","date":"2025-05-24T07:39:36.000Z","url":"/posts/A-name-picker-based-on-Python/","tags":[["Python","/tags/Python/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["软件开发","/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"]],"content":"要实现的功能 随机点名 在一定数量范围内不会重复点到同一个人 便于操作的图形化界面 修改指定名字被点到的概率 功能的实现库的导入使用tkinter和random库可以帮助我们实现图形化界面和随机点名： 搭建图形界面用以下的代码可以搭建一个简单的点名页面： 其中： self.result为显示点名结果的标签。 self.pick_button为开始&#x2F;结束按钮。 获取名单为实现随机点名，我们必须要做的是获取所有人的姓名，其可以用以下代码实现： 其中： 文件names.txt是储存名单的文件。 列表self.names用于在程序中储存名单。 函数tf.read().split(&quot;\\n&quot;)用于按照换行分割名字 引号中的文件名在没有路径修饰的情况下会默认读取与程序同目录下的文件。我们也可以将其改成绝对路径： 随机点名要实现随机点名，我们需要调用random下的choice来在列表中选择： 排除点过的名字我们不会希望一个人因为运气好而被连续点到，因此需要在点到一个人后将他的名字排除在外。 我们先定义一个列表用于储存已经点过的名字： 然后将列表中的名字排除： 将点名结果显示在屏幕上将点名结果final_name显示在结果标签中，然后将其记录在self.named中： 点名时实现滚动动画为营造点名的紧张感，我们可以用以下代码来实现名字在屏幕上滚动的效果： 其中：self.is_picking记录了点名器的状态，其可以用先前定义的按钮来控制： 实现隐藏功能 隐藏的内容 在此基础上我们可以实现修改指定名字被点到的概率。首先定义一个列表用于储存特殊的名字： 然后修改他被点到的概率： 其中：random.random() &lt; 0.5代表其被点到后有50%的概率被跳过。 成品"},{"title":"你好，世界！","date":"2025-05-23T16:00:00.000Z","url":"/posts/hello-world/","tags":[["欢迎","/tags/%E6%AC%A2%E8%BF%8E/"]],"categories":[["开始","/categories/%E5%BC%80%E5%A7%8B/"]],"content":"欢迎来到luthree’s Blog"},{"date":"2025-06-01T04:34:55.557Z","url":"/comments/waline.js","categories":[["undefined",""]],"content":"import { init, commentCount } from ''; import { pageviewCount } from ''; (() => { const serverURL = 'waline.luthr.ee'; let firstVisit = true; const loadComments = async () => { const container = document.getElementById('w-comments'); if (!!container) { // 是文章或页面，完整加载 Waline const path = container.getAttribute(\"data-path\"); init({ el: container, path, dark: 'html[data-theme=\"dark\"]', serverURL, pageview: true, comment: true, }); } else { // 是首页，只展示页面访问和评论数量，不渲染评论区 pageviewCount({ serverURL, update: false, }); commentCount({ serverURL, }); } if (firstVisit) { // 站点的访问统计，仅生效一次 firstVisit = false; pageviewCount({ serverURL, path: \"/index.html\", }); } }; window.loadComments = loadComments; window.addEventListener('pjax:success', () => { window.loadComments = loadComments; }); })();"},{"date":"2025-06-01T04:34:27.559Z","url":"/comments/waline.css","categories":[["undefined",""]],"content":"#w-comments .wl-reaction-list { gap: 24px; } #w-comments .wl-reaction-img { width: 72px; height: 72px; } #w-comments .wl-reaction-votes { font-size: 1em; }"},{"date":"2025-05-24T03:06:51.723Z","url":"/effects/cursor-effects.js","categories":[["undefined",""]],"content":"class Circle { constructor({ origin, speed, color, angle, context }) { this.origin = origin this.position = { ...this.origin } this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 } draw() { this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() } move() { this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ } } class Boom { constructor ({ origin, context, circleCount = 10, area }) { this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] } randomArray(range) { const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] } randomColor() { const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) } randomRange(start, end) { return (end - start) * Math.random() + start } init() { for(let i = 0; i < this.circleCount; i++) { const circle = new Circle({ context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) }) this.circles.push(circle) } } move() { this.circles.forEach((circle, index) => { if (circle.position.x > this.area.width || circle.position.y > this.area.height) { return this.circles.splice(index, 1) } circle.move() }) if (this.circles.length == 0) { this.stop = true } } draw() { this.circles.forEach(circle => circle.draw()) } } class CursorSpecialEffects { constructor() { this.computerCanvas = document.createElement('canvas') this.renderCanvas = document.createElement('canvas') this.computerContext = this.computerCanvas.getContext('2d') this.renderContext = this.renderCanvas.getContext('2d') this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false } handleMouseDown(e) { const boom = new Boom({ origin: { x: e.clientX, y: e.clientY }, context: this.computerContext, area: { width: this.globalWidth, height: this.globalHeight } }) boom.init() this.booms.push(boom) this.running || this.run() } handlePageHide() { this.booms = [] this.running = false } init() { const style = this.renderCanvas.style style.position = 'fixed' style.top = style.left = 0 style.zIndex = '999999999999999999999999999999999999999999' style.pointerEvents = 'none' style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener('mousedown', this.handleMouseDown.bind(this)) window.addEventListener('pagehide', this.handlePageHide.bind(this)) } run() { this.running = true if (this.booms.length == 0) { return this.running = false } requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) => { if (boom.stop) { return this.booms.splice(index, 1) } boom.move() boom.draw() }) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) } } const cursorSpecialEffects = new CursorSpecialEffects() cursorSpecialEffects.init()"},{"date":"2025-05-24T03:08:41.526Z","url":"/effects/snow.css","categories":[["undefined",""]],"content":"#snow { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 99999; pointer-events: none; background: rgba(225, 225, 225, .05); }"},{"date":"2025-05-24T03:08:40.389Z","url":"/effects/snow.js","categories":[["undefined",""]],"content":"(()=>{ // 设置雪花参数 const snowConf = { flakeCount: 100, minDist: 150, color: \"255, 255, 255\", size: 2, speed: 0.5, opacity: 0.3, stepsize: .5, }; // 记录下雪状态 let isSnowing = true; const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback){window.setTimeout(callback, 1000/60);}; window.requestAnimationFrame = requestAnimationFrame; const canvas = document.getElementById(\"snow\"); const ctx = canvas.getContext(\"2d\"); const flakeCount = snowConf.flakeCount; let mX = -100, mY = -100; let flakes = []; canvas.width = window.innerWidth; canvas.height = window.innerHeight; const snow = () => { if (!isSnowing) { return; // 结束 } // 清空画布 ctx.clearRect(0, 0, canvas.width, canvas.height); const minDist = snowConf.minDist; for (let i = 0; i < flakeCount; i++){ let flake = flakes[i]; const x = mX, y = mY; const x2 = flake.x, y2 = flake.y; const dist = Math.sqrt((x - x2)*(x - x2) + (y - y2)*(y - y2)); if (dist < minDist) { const force = minDist / (dist*dist); const xcomp = (x - x2) / dist; const ycomp = (y - y2) / dist; const deltaV = force / 2; flake.velX -= deltaV * xcomp; flake.velY -= deltaV * ycomp; } else { flake.velX *= 0.98; if (flake.velY < flake.speed && (flake.speed - flake.velY > .01)) { flake.velY += (flake.speed - flake.velY) * .01; } flake.velX += Math.cos(flake.step += .05) * flake.stepSize; } ctx.fillStyle = \"rgba(\" + snowConf.color + \", \" + flake.opacity + \")\"; flake.y += flake.velY; flake.x += flake.velX; if(flake.y >= canvas.height || flake.y = canvas.width || flake.x { flake.x = Math.floor(Math.random()*canvas.width); flake.y = 0; flake.size = (Math.random()*3)+2; flake.speed = (Math.random()*1)+0.5; flake.velY = flake.speed; flake.velX = 0; flake.opacity = (Math.random()*0.5)+0.3; }; const startSnow = () => { // 生成初始雪花 for (let i = 0; i < flakeCount; i++) { const x = Math.floor(Math.random()*canvas.width); const y = Math.floor(Math.random()*canvas.height); const size = (Math.random()*3) + snowConf.size; const speed = (Math.random()*1) + snowConf.speed; const opacity = (Math.random()*0.5) + snowConf.opacity; flakes.push({ speed: speed, velX: 0, velY: speed, x: x, y: y, size: size, stepSize: (Math.random()) / 30 * snowConf.stepsize, step: 0, angle: 180, opacity: opacity }); } // 开始下雪 snow(); }; // 雪花避让鼠标 document.addEventListener(\"mousemove\", (e)=>{mX = e.clientX, mY = e.clientY}); // 窗口大小调整 window.addEventListener(\"resize\",()=>{canvas.width = window.innerWidth; canvas.height = window.innerHeight;}); // 初始化 startSnow(); })();"},{"date":"2025-05-24T03:20:52.260Z","url":"/others/mobile-hero.css","categories":[["undefined",""]],"content":"@media (max-width: 768px) { .kratos-start { height: unset !important; } .kratos-cover.kratos-cover-2.text-center { display: block; } }"}]