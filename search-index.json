[{"title":"基于Python的图形化点名系统","date":"2025-05-24T07:39:36.000Z","url":"/posts/A-name-picker-based-on-Python/","tags":[["Python","/tags/Python/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["软件开发","/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"]],"content":"一、要实现的功能 随机点名 在一定数量范围内不会重复点到同一个人 便于操作的图形化界面 修改指定名字被点到的概率 二、功能的实现1. 库的导入使用tklinker和random库可以帮助我们实现图形化界面和随机点名： 2. 搭建图形界面用以下的代码可以搭建一个简单的点名页面： 其中： self.result为显示点名结果的标签。 self.pick_button为开始&#x2F;结束按钮。 3. 获取名单为实现随机点名，我们必须要做的是获取所有人的姓名，其可以用以下代码实现： 其中： 文件names.txt是储存名单的文件。 列表self.names用于在程序中储存名单。 函数tf.read().split(&quot;\\n&quot;)用于按照换行分割名字 引号中的文件名在没有路径修饰的情况下会默认读取与程序同目录下的文件。我们也可以将其改成绝对路径： 4. 随机点名要实现随机点名，我们需要调用random下的choice来在列表中选择： 5. 排除点过的名字我们不会希望一个人因为运气好而被连续点到，因此需要在点到一个人后将他的名字排除在外。 我们先定义一个列表用于储存已经点过的名字： 然后将列表中的名字排除： 6. 将点名结果显示在屏幕上将点名结果final_name显示在结果标签中，然后将其记录在self.named中： 7. 点名时实现滚动动画为营造点名的紧张感，我们可以用以下代码来实现名字在屏幕上滚动的效果： 其中：self.is_picking记录了点名器的状态，其可以用先前定义的按钮来控制： 8. 实现隐藏功能 隐藏的内容 在此基础上我们可以实现修改指定名字被点到的概率。首先定义一个列表用于储存特殊的名字： 然后修改他被点到的概率： 其中：random.random() &lt; 0.5代表其被点到后有50%的概率被跳过。 三、 成品"},{"title":"你好，世界！","date":"2025-05-23T16:00:00.000Z","url":"/posts/hello-world/","tags":[["欢迎","/tags/%E6%AC%A2%E8%BF%8E/"]],"categories":[["开始","/categories/%E5%BC%80%E5%A7%8B/"]],"content":"欢迎来到luthree’s Blog"},{"date":"2025-05-24T03:08:40.389Z","url":"/effects/snow.js","categories":[["undefined",""]],"content":"(()=>{ // 设置雪花参数 const snowConf = { flakeCount: 100, minDist: 150, color: \"255, 255, 255\", size: 2, speed: 0.5, opacity: 0.3, stepsize: .5, }; // 记录下雪状态 let isSnowing = true; const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback){window.setTimeout(callback, 1000/60);}; window.requestAnimationFrame = requestAnimationFrame; const canvas = document.getElementById(\"snow\"); const ctx = canvas.getContext(\"2d\"); const flakeCount = snowConf.flakeCount; let mX = -100, mY = -100; let flakes = []; canvas.width = window.innerWidth; canvas.height = window.innerHeight; const snow = () => { if (!isSnowing) { return; // 结束 } // 清空画布 ctx.clearRect(0, 0, canvas.width, canvas.height); const minDist = snowConf.minDist; for (let i = 0; i < flakeCount; i++){ let flake = flakes[i]; const x = mX, y = mY; const x2 = flake.x, y2 = flake.y; const dist = Math.sqrt((x - x2)*(x - x2) + (y - y2)*(y - y2)); if (dist < minDist) { const force = minDist / (dist*dist); const xcomp = (x - x2) / dist; const ycomp = (y - y2) / dist; const deltaV = force / 2; flake.velX -= deltaV * xcomp; flake.velY -= deltaV * ycomp; } else { flake.velX *= 0.98; if (flake.velY < flake.speed && (flake.speed - flake.velY > .01)) { flake.velY += (flake.speed - flake.velY) * .01; } flake.velX += Math.cos(flake.step += .05) * flake.stepSize; } ctx.fillStyle = \"rgba(\" + snowConf.color + \", \" + flake.opacity + \")\"; flake.y += flake.velY; flake.x += flake.velX; if(flake.y >= canvas.height || flake.y = canvas.width || flake.x { flake.x = Math.floor(Math.random()*canvas.width); flake.y = 0; flake.size = (Math.random()*3)+2; flake.speed = (Math.random()*1)+0.5; flake.velY = flake.speed; flake.velX = 0; flake.opacity = (Math.random()*0.5)+0.3; }; const startSnow = () => { // 生成初始雪花 for (let i = 0; i < flakeCount; i++) { const x = Math.floor(Math.random()*canvas.width); const y = Math.floor(Math.random()*canvas.height); const size = (Math.random()*3) + snowConf.size; const speed = (Math.random()*1) + snowConf.speed; const opacity = (Math.random()*0.5) + snowConf.opacity; flakes.push({ speed: speed, velX: 0, velY: speed, x: x, y: y, size: size, stepSize: (Math.random()) / 30 * snowConf.stepsize, step: 0, angle: 180, opacity: opacity }); } // 开始下雪 snow(); }; // 雪花避让鼠标 document.addEventListener(\"mousemove\", (e)=>{mX = e.clientX, mY = e.clientY}); // 窗口大小调整 window.addEventListener(\"resize\",()=>{canvas.width = window.innerWidth; canvas.height = window.innerHeight;}); // 初始化 startSnow(); })();"},{"date":"2025-05-24T03:08:41.526Z","url":"/effects/snow.css","categories":[["undefined",""]],"content":"#snow { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 99999; pointer-events: none; background: rgba(225, 225, 225, .05); }"},{"date":"2025-05-24T03:06:51.723Z","url":"/effects/cursor-effects.js","categories":[["undefined",""]],"content":"class Circle { constructor({ origin, speed, color, angle, context }) { this.origin = origin this.position = { ...this.origin } this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 } draw() { this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() } move() { this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ } } class Boom { constructor ({ origin, context, circleCount = 10, area }) { this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] } randomArray(range) { const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] } randomColor() { const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) } randomRange(start, end) { return (end - start) * Math.random() + start } init() { for(let i = 0; i < this.circleCount; i++) { const circle = new Circle({ context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) }) this.circles.push(circle) } } move() { this.circles.forEach((circle, index) => { if (circle.position.x > this.area.width || circle.position.y > this.area.height) { return this.circles.splice(index, 1) } circle.move() }) if (this.circles.length == 0) { this.stop = true } } draw() { this.circles.forEach(circle => circle.draw()) } } class CursorSpecialEffects { constructor() { this.computerCanvas = document.createElement('canvas') this.renderCanvas = document.createElement('canvas') this.computerContext = this.computerCanvas.getContext('2d') this.renderContext = this.renderCanvas.getContext('2d') this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false } handleMouseDown(e) { const boom = new Boom({ origin: { x: e.clientX, y: e.clientY }, context: this.computerContext, area: { width: this.globalWidth, height: this.globalHeight } }) boom.init() this.booms.push(boom) this.running || this.run() } handlePageHide() { this.booms = [] this.running = false } init() { const style = this.renderCanvas.style style.position = 'fixed' style.top = style.left = 0 style.zIndex = '999999999999999999999999999999999999999999' style.pointerEvents = 'none' style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener('mousedown', this.handleMouseDown.bind(this)) window.addEventListener('pagehide', this.handlePageHide.bind(this)) } run() { this.running = true if (this.booms.length == 0) { return this.running = false } requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) => { if (boom.stop) { return this.booms.splice(index, 1) } boom.move() boom.draw() }) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) } } const cursorSpecialEffects = new CursorSpecialEffects() cursorSpecialEffects.init()"},{"date":"2025-05-24T03:20:52.260Z","url":"/others/mobile-hero.css","categories":[["undefined",""]],"content":"@media (max-width: 768px) { .kratos-start { height: unset !important; } .kratos-cover.kratos-cover-2.text-center { display: block; } }"}]